## Задание #1:

>написать модуль, который экспортирует аналоги методов для работы с массивами:
>forEach, filter, map, slice, reduce, splice  пример:
```javascript
let array = [1, 2, 3, 4, 5, 6];
forEach(array, item => console.log(item));
let greaterThan4 = filter(array, item => item > 4);
let sqare = map(array, item => item*item);
```
>Описание того, как работают эти методы, есть на Mozilla Developer Network и в бесплатных видеоуроках LoftBlog/LoftSchool.
>     
>Реализация функции splice является задачей со звездочкой.
>Ее выполнение не обязательно, но желательно.

>Внимание:
> в данном задании запрещено использовать встроенные методы для работы с массивами! Разрешено использовать стандартные 
>операторы 'for/for-in/while/if`' (и т.д.) и свойство 'length'

## Моё решение:

Ход решения описан в файле index.js, часть написана на русском( т.к писал поздно вечером переводить было лень:) ). 

## Задание #2: 

>Как известно, в js не существует способа проверить идентичность объектов.
>Написав 'objA === objB' мы получим true только в том случае, если objA и objB указывают на один и тот же объект.
>
>Задача: написать функцию deepEqual, которая принимает в качестве параметров два аргуманта - два объекта.
>
>Если обе переменные указывают на один и тот же объект, значит оба объекта идентичны.
>
>Если оба объекта имеют одинаковые свойства и их значения, значит оба объекта идентичны.
>
>Посмотрите на примеры того, как должна работать фиункция deepEqual:
```javascript
var objA = {
    prop1: 'value1',
    prop2: 'value2',
    prop3: 'value3',
    prop4: {
        subProp1: 'sub value1',
        subProp2: {
            subSubProp1: 'sub sub value1',
            subSubProp2: [1, 2, {prop2: 1, prop: 2}, 4, 5]
        }
    },
    prop5: 1000,
    prop6: new Date(2016, 2, 10)
};

var objB = {
    prop5: 1000,
    prop3: 'value3',
    prop1: 'value1',
    prop2: 'value2',
    prop6: new Date('2016/03/10'),
    prop4: {
        subProp2: {
            subSubProp1: 'sub sub value1',
            subSubProp2: [1, 2, {prop2: 1, prop: 2}, 4, 5]
        },
        subProp1: 'sub value1'
    }
};

console.log(deepEqual(objA, objB)); //объекты идентичны, вернет true
```

>Не смотря на то, что свойства в objB перемешаны(последовательность свойста в objB отичается от последовательности свойств в objA), функция всё равно вернет true, так как количество свойств, из имена и значения совпадают у обоих объектов.
>Так же обратите вснимание, что deepEqual должна работать рекурсивно. 
>
>Это значит, что если значением какого-то свойства объекта является массив или объект, то начать сверять и их у обоих объектов.
>
>Если одним из элементов сверяемого массива, является другой массив или объект, то их тоже надо сверить рекурсивно.
>
>При сверке объектов - последовательность свойств не важна, но при сверке массивов, вашна последовательность элементов, то есть массивы: `[1,2,3,4]` и `[2,1,3,4]` не равны, так как, хотя и имеют одинаковые значения, отличаются в последовательности этих значений.
>
>Так же обратите внимание, что даты тоже должны сравниваться корректно, не смотря на отличия в способах создания.
>
>Запрещено использовать сторонние библиотеки типа jQuery, underscore и прочие.

## Моё решение:

Код находится в файле deepequal.js, пока без описания т.к нет времени на это. Если нашли баг в работе моего решения напишите об этов в issue. 